/**
 * Î∏îÎ°ù Î≥ëÌï© ÏãúÏä§ÌÖú
 * 
 * @description Îã§ÏñëÌïú Î∏îÎ°ù ÌÉÄÏûÖ Í∞ÑÏùò Ïä§ÎßàÌä∏Ìïú Î≥ëÌï©ÏùÑ Ï≤òÎ¶¨
 * - ÌÖçÏä§Ìä∏ ‚Üí Î¶¨Ïä§Ìä∏: ÌÖçÏä§Ìä∏Î•º Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖúÏúºÎ°ú Ï∂îÍ∞Ä
 * - Î¶¨Ïä§Ìä∏ ‚Üí Î¶¨Ïä§Ìä∏: Î¶¨Ïä§Ìä∏ ÌÉÄÏûÖ Î≥ÄÌôò ÎòêÎäî ÏïÑÏù¥ÌÖú Î≥ëÌï©
 * - Ìó§Îî© ‚Üí Ìó§Îî©: Î†àÎ≤® ÌÜµÏùº ÎòêÎäî ÎÇ¥Ïö© Î≥ëÌï©
 * - Ïä§ÎßàÌä∏ Î≥ëÌï©: ÏûêÎèôÏúºÎ°ú ÏµúÏ†ÅÏùò Î≥ëÌï© Î∞©Ïãù ÏÑ†ÌÉù
 * 
 * @author AI Assistant
 * @version 1.0.0
 */

// Ï†ÑÏ≤¥ Î∏îÎ°ù ÌÉÄÏûÖ Ï†ïÏùò (35Í∞ú ÌÉÄÏûÖ)
const ALL_BLOCK_TYPES = [
  // Í∏∞Î≥∏/ÌÖçÏä§Ìä∏ Î∏îÎ°ù
  'text', 'heading1', 'heading2', 'heading3', 'quote', 'divider', 'code', 
  'bulletList', 'numberedList', 'checkList',
  
  // ÎØ∏ÎîîÏñ¥ Î∏îÎ°ù  
  'image', 'video', 'audio', 'file', 'column', 'gallery',
  
  // Îç∞Ïù¥ÌÑ∞/Ìëú Î∏îÎ°ù
  'table', 'chart', 'timeline', 'board', 'progressBar', 'rating',
  
  // Ïù∏ÌÑ∞ÎûôÌã∞Î∏å Î∏îÎ°ù
  'toggle', 'button', 'poll', 'comment', 'tag', 'alert',
  
  // ÏûÑÎ≤†Îìú/Ïô∏Î∂Ä Î∏îÎ°ù
  'webEmbed', 'pdfEmbed', 'mermaid', 'math', 'customHTML', 'profile',
  
  // ÌéòÏù¥ÏßÄ Î∏îÎ°ù
  'page'
];

// ÌÜµÌï© Ïª®ÌÖêÏ∏† Ïù¥Îèô ÏãúÏä§ÌÖú - Î≥ëÌï© Í∑úÏπô Ï†ïÏùò
export const MERGE_RULES = {
  // === ÌÖçÏä§Ìä∏ Í≥ÑÏó¥ Î≥ëÌï© ===
  TEXT_TO_TEXT: {
    sourceTypes: ['text'],
    targetTypes: ['text'],
    strategy: 'content_concatenate',
    description: 'ÌÖçÏä§Ìä∏ Î∏îÎ°ù ÎÇ¥Ïö© Î≥ëÌï©',
    priority: 10
  },
  
  TEXT_TO_LIST: {
    sourceTypes: ['text'],
    targetTypes: ['bulletList', 'numberedList', 'checkList'],
    strategy: 'append_as_item',
    description: 'ÌÖçÏä§Ìä∏Î•º Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖúÏúºÎ°ú Ï∂îÍ∞Ä'
  },
  
  TEXT_TO_TOGGLE: {
    sourceTypes: ['text'],
    targetTypes: ['toggle'],
    strategy: 'wrap_in_toggle',
    description: 'ÌÖçÏä§Ìä∏Î•º ÌÜ†Í∏Ä Î∏îÎ°ùÏúºÎ°ú ÎûòÌïë'
  },
  
  TEXT_TO_CODE: {
    sourceTypes: ['text'],
    targetTypes: ['code'],
    strategy: 'wrap_in_code',
    description: 'ÌÖçÏä§Ìä∏Î•º ÏΩîÎìú Î∏îÎ°ùÏúºÎ°ú Î≥ÄÌôò'
  },
  
  TEXT_TO_QUOTE: {
    sourceTypes: ['text'],
    targetTypes: ['quote'],
    strategy: 'wrap_in_quote',
    description: 'ÌÖçÏä§Ìä∏Î•º Ïù∏Ïö©Íµ¨Î°ú Î≥ÄÌôò'
  },
  
  // === Î¶¨Ïä§Ìä∏ Í≥ÑÏó¥ Î≥ëÌï© ===
  LIST_TO_LIST: {
    sourceTypes: ['bulletList', 'numberedList', 'checkList'],
    targetTypes: ['bulletList', 'numberedList', 'checkList'],
    strategy: 'merge_items_or_convert',
    description: 'Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖú Î≥ëÌï© ÎòêÎäî ÌÉÄÏûÖ Î≥ÄÌôò'
  },
  
  LIST_TO_TOGGLE: {
    sourceTypes: ['bulletList', 'numberedList', 'checkList'],
    targetTypes: ['toggle'],
    strategy: 'list_to_toggle',
    description: 'Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖúÎì§ÏùÑ ÌÜ†Í∏Ä Î∏îÎ°ùÏúºÎ°ú Î≥ÄÌôò'
  },
  
  LIST_TO_TEXT: {
    sourceTypes: ['bulletList', 'numberedList', 'checkList'],
    targetTypes: ['text'],
    strategy: 'extract_list_content',
    description: 'Î¶¨Ïä§Ìä∏ ÎÇ¥Ïö©ÏùÑ ÌÖçÏä§Ìä∏Î°ú Ï∂îÏ∂ú'
  },
  
  // === Ìó§Îî© Í≥ÑÏó¥ Î≥ëÌï© ===
  HEADING_TO_HEADING: {
    sourceTypes: ['heading1', 'heading2', 'heading3'],
    targetTypes: ['heading1', 'heading2', 'heading3'],
    strategy: 'level_unify_or_merge',
    description: 'Ìó§Îî© Î†àÎ≤® ÌÜµÏùº ÎòêÎäî ÎÇ¥Ïö© Î≥ëÌï©'
  },
  
  HEADING_TO_TOGGLE: {
    sourceTypes: ['heading1', 'heading2', 'heading3'],
    targetTypes: ['toggle'],
    strategy: 'heading_to_toggle',
    description: 'Ìó§Îî©ÏùÑ ÌÜ†Í∏Ä Ï†úÎ™©ÏúºÎ°ú Î≥ÄÌôò'
  },
  
  // === ÌÜ†Í∏Ä Í≥ÑÏó¥ Î≥ëÌï© ===
  TOGGLE_TO_TOGGLE: {
    sourceTypes: ['toggle'],
    targetTypes: ['toggle'],
    strategy: 'merge_toggle_content',
    description: 'ÌÜ†Í∏Ä Î∏îÎ°ù ÎÇ¥Ïö© Î≥ëÌï©'
  },
  
  ANY_TO_TOGGLE: {
    sourceTypes: ALL_BLOCK_TYPES.filter(type => type !== 'toggle'),
    targetTypes: ['toggle'],
    strategy: 'wrap_in_toggle',
    description: 'Î™®Îì† Î∏îÎ°ùÏùÑ ÌÜ†Í∏ÄÎ°ú ÎûòÌïë'
  },
  
  // === ÏΩîÎìú Í≥ÑÏó¥ Î≥ëÌï© ===
  CODE_TO_CODE: {
    sourceTypes: ['code'],
    targetTypes: ['code'],
    strategy: 'merge_code_content',
    description: 'ÏΩîÎìú Î∏îÎ°ù ÎÇ¥Ïö© Î≥ëÌï©',
    priority: 10
  },
  
  // === Ïù∏Ïö©Íµ¨ Í≥ÑÏó¥ Î≥ëÌï© ===
  QUOTE_TO_QUOTE: {
    sourceTypes: ['quote'],
    targetTypes: ['quote'],
    strategy: 'content_concatenate',
    description: 'Ïù∏Ïö©Íµ¨ Î∏îÎ°ù ÎÇ¥Ïö© Î≥ëÌï©',
    priority: 10
  },
  
  // === ÎØ∏ÎîîÏñ¥ Í≥ÑÏó¥ Î≥ëÌï© ===
  IMAGE_TO_GALLERY: {
    sourceTypes: ['image'],
    targetTypes: ['gallery'],
    strategy: 'add_to_gallery',
    description: 'Ïù¥ÎØ∏ÏßÄÎ•º Í∞§Îü¨Î¶¨Ïóê Ï∂îÍ∞Ä'
  },
  
  FILE_TO_FILE: {
    sourceTypes: ['file'],
    targetTypes: ['file'],
    strategy: 'merge_file_list',
    description: 'ÌååÏùº Î™©Î°ù Î≥ëÌï©'
  },
  
  // === Î≤îÏö© Î≥ëÌï© Í∑úÏπô ===
  ANY_TO_TEXT: {
    sourceTypes: ALL_BLOCK_TYPES.filter(type => type !== 'text'),
    targetTypes: ['text'],
    strategy: 'extract_text_and_merge',
    description: 'Î™®Îì† Î∏îÎ°ùÏùò ÌÖçÏä§Ìä∏ ÎÇ¥Ïö©ÏùÑ Ï∂îÏ∂úÌïòÏó¨ Î≥ëÌï©'
  },
  
  ANY_TO_COLUMN: {
    sourceTypes: ALL_BLOCK_TYPES.filter(type => type !== 'column'),
    targetTypes: ['column'],
    strategy: 'add_to_column',
    description: 'Î∏îÎ°ùÏùÑ Ïª¨ÎüºÏóê Ï∂îÍ∞Ä'
  },
  
  // === Ïª¨Îüº Í∑∏Î£π ÏÉùÏÑ± ===
  MULTI_TO_COLUMN_GROUP: {
    sourceTypes: ALL_BLOCK_TYPES,
    targetTypes: ALL_BLOCK_TYPES,
    strategy: 'create_column_group',
    description: 'ÏÑ†ÌÉùÎêú Î∏îÎ°ùÎì§ÏùÑ Ïª¨Îüº Í∑∏Î£πÏúºÎ°ú Î≥ÄÌôò',
    minSourceCount: 2
  },
  
  // === ÏµúÏ¢Ö Î≤îÏö© Í∑úÏπô (fallback) ===
  ANY_TO_ANY: {
    sourceTypes: ALL_BLOCK_TYPES,
    targetTypes: ALL_BLOCK_TYPES,
    strategy: 'universal_content_transfer',
    description: 'Î≤îÏö© Ïª®ÌÖêÏ∏† Ïù¥Îèô (ÎÇ¥Ïö© Î≥¥Ï°¥ÌïòÎ©∞ ÌÉÄÏûÖ Î≥ÄÌôò)',
    priority: -1 // ÏµúÏ†Ä Ïö∞ÏÑ†ÏàúÏúÑ (Îã§Î•∏ Í∑úÏπôÏù¥ ÏóÜÏùÑ ÎïåÎßå ÏÇ¨Ïö©)
  }
};

/**
 * Î∏îÎ°ù Î≥ëÌï© ÌÅ¥ÎûòÏä§
 */
export class BlockMerger {
  constructor(config = {}) {
    this.config = {
      preserveFormatting: true,
      smartMerging: true,
      maxMergeItems: 50,
      debugMode: false,
      ...config
    };
    
    if (this.config.debugMode) {
      console.log('üîó BlockMerger initialized');
    }
  }
  
  /**
   * Î∏îÎ°ù Î≥ëÌï© Ïã§Ìñâ
   * @param {Array} sourceBlocks - ÏÜåÏä§ Î∏îÎ°ùÎì§
   * @param {Object} targetBlock - ÌÉÄÍ≤ü Î∏îÎ°ù
   * @param {Object} options - Î≥ëÌï© ÏòµÏÖò
   * @returns {Object} Î≥ëÌï© Í≤∞Í≥º
   */
  async merge(sourceBlocks, targetBlock, options = {}) {
    try {
      console.log('üîó BlockMerger.merge ÏãúÏûë:', { sourceBlocks, targetBlock, options });
      
      // Î≥ëÌï© Í∑úÏπô Ï∞æÍ∏∞
      const rule = this.findMergeRule(sourceBlocks, targetBlock);
      console.log('üìã Ï∞æÏùÄ Î≥ëÌï© Í∑úÏπô:', rule);
      
      if (!rule) {
        const error = {
          success: false,
          error: 'No compatible merge rule found',
          sourceTypes: sourceBlocks.map(b => b.type),
          targetType: targetBlock.type
        };
        console.log('‚ùå Î≥ëÌï© Í∑úÏπô ÏóÜÏùå:', error);
        return error;
      }
      
      if (this.config.debugMode) {
        console.log('üéØ Using merge rule:', rule.description);
      }
      
      // Ï†ÑÎûµÏóê Îî∞Î•∏ Î≥ëÌï© Ïã§Ìñâ (ÌÜµÌï© Ïª®ÌÖêÏ∏† Ïù¥Îèô ÏãúÏä§ÌÖú)
      let result;
      switch (rule.strategy) {
        // === Í∏∞Ï°¥ Ï†ÑÎûµÎì§ ===
        case 'append_as_item':
          result = await this.appendAsListItem(sourceBlocks, targetBlock, options);
          break;
          
        case 'merge_items_or_convert':
          result = await this.mergeListItems(sourceBlocks, targetBlock, options);
          break;
          
        case 'level_unify_or_merge':
          result = await this.unifyHeadingLevel(sourceBlocks, targetBlock, options);
          break;
          
        case 'content_concatenate':
          result = await this.concatenateContent(sourceBlocks, targetBlock, options);
          break;
          
        case 'extract_text_and_merge':
          result = await this.extractAndMergeText(sourceBlocks, targetBlock, options);
          break;
          
        case 'create_column_group':
          result = await this.createColumnGroup(sourceBlocks, targetBlock, options);
          break;
          
        // === ÏÉàÎ°úÏö¥ ÌÜµÌï© Ï†ÑÎûµÎì§ ===
        case 'wrap_in_toggle':
          result = await this.wrapInToggle(sourceBlocks, targetBlock, options);
          break;
          
        case 'wrap_in_code':
          result = await this.wrapInCode(sourceBlocks, targetBlock, options);
          break;
          
        case 'wrap_in_quote':
          result = await this.wrapInQuote(sourceBlocks, targetBlock, options);
          break;
          
        case 'list_to_toggle':
          result = await this.listToToggle(sourceBlocks, targetBlock, options);
          break;
          
        case 'extract_list_content':
          result = await this.extractListContent(sourceBlocks, targetBlock, options);
          break;
          
        case 'heading_to_toggle':
          result = await this.headingToToggle(sourceBlocks, targetBlock, options);
          break;
          
        case 'merge_toggle_content':
          result = await this.mergeToggleContent(sourceBlocks, targetBlock, options);
          break;
          
        case 'merge_code_content':
          result = await this.mergeCodeContent(sourceBlocks, targetBlock, options);
          break;
          
        case 'add_to_gallery':
          result = await this.addToGallery(sourceBlocks, targetBlock, options);
          break;
          
        case 'merge_file_list':
          result = await this.mergeFileList(sourceBlocks, targetBlock, options);
          break;
          
        case 'add_to_column':
          result = await this.addToColumn(sourceBlocks, targetBlock, options);
          break;
          
        case 'universal_content_transfer':
          result = await this.universalContentTransfer(sourceBlocks, targetBlock, options);
          break;
          
        default:
          throw new Error(`Unknown merge strategy: ${rule.strategy}`);
      }
      
      const finalResult = {
        success: true,
        strategy: rule.strategy,
        rule: rule.description,
        ...result
      };
      
      console.log('‚úÖ BlockMerger.merge ÏÑ±Í≥µ:', finalResult);
      return finalResult;
      
    } catch (error) {
      const errorResult = {
        success: false,
        error: error.message
      };
      console.log('‚ùå BlockMerger.merge Ïã§Ìå®:', errorResult);
      return errorResult;
    }
  }
  
  /**
   * ÌÖçÏä§Ìä∏Î•º Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖúÏúºÎ°ú Ï∂îÍ∞Ä
   */
  async appendAsListItem(sourceBlocks, targetBlock, options) {
    const changes = [];
    const newItems = [];
    
    // ÌÉÄÍ≤ü Î¶¨Ïä§Ìä∏Ïùò Í∏∞Ï°¥ ÏïÑÏù¥ÌÖúÎì§ ÌååÏã±
    let existingItems = this.parseListItems(targetBlock.content);
    let currentIndex = existingItems.length;
    
    // ÏÜåÏä§ ÌÖçÏä§Ìä∏Îì§ÏùÑ Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖúÏúºÎ°ú Î≥ÄÌôò
    sourceBlocks.forEach(sourceBlock => {
      const itemContent = this.extractTextContent(sourceBlock);
      if (itemContent.trim()) {
        currentIndex++;
        const newItem = this.createListItem(targetBlock.type, itemContent, currentIndex);
        existingItems.push(newItem);
        newItems.push(newItem);
        
        // ÏÜåÏä§ Î∏îÎ°ù ÏÇ≠Ï†ú Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Í∏∞Î°ù
        changes.push({
          action: 'delete',
          blockId: sourceBlock.id
        });
      }
    });
    
    // ÌÉÄÍ≤ü Î∏îÎ°ù ÏóÖÎç∞Ïù¥Ìä∏
    const updatedContent = this.formatListContent(targetBlock.type, existingItems);
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldContent: targetBlock.content,
      newContent: updatedContent,
      contentData: {
        type: 'doc',
        content: [{
          type: 'paragraph',
          content: [{
            type: 'text',
            text: updatedContent
          }]
        }]
      }
    });
    
    return {
      data: {
        itemsAdded: newItems.length,
        totalItems: existingItems.length,
        newItems
      },
      changes
    };
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖú Î≥ëÌï© ÎòêÎäî ÌÉÄÏûÖ Î≥ÄÌôò
   */
  async mergeListItems(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Í∞ôÏùÄ ÌÉÄÏûÖÏù¥Î©¥ ÏïÑÏù¥ÌÖú Î≥ëÌï©, Îã§Î•∏ ÌÉÄÏûÖÏù¥Î©¥ Î≥ÄÌôò
    const isSameType = sourceBlocks.every(block => block.type === targetBlock.type);
    
    if (isSameType) {
      // ÏïÑÏù¥ÌÖú Î≥ëÌï©
      return this.appendAsListItem(sourceBlocks, targetBlock, options);
    } else {
      // ÌÉÄÏûÖ Î≥ÄÌôò ÌõÑ Î≥ëÌï©
      const convertedBlocks = sourceBlocks.map(block => ({
        ...block,
        type: targetBlock.type,
        content: this.convertListItemContent(block.content, block.type, targetBlock.type)
      }));
      
      return this.appendAsListItem(convertedBlocks, targetBlock, options);
    }
  }
  
  /**
   * Ìó§Îî© Î†àÎ≤® ÌÜµÏùº ÎòêÎäî ÎÇ¥Ïö© Î≥ëÌï©
   */
  async unifyHeadingLevel(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    if (options.strategy === 'unify_level') {
      // ÏÜåÏä§ Î∏îÎ°ùÎì§ÏùÑ ÌÉÄÍ≤üÍ≥º Í∞ôÏùÄ Î†àÎ≤®Î°ú Î≥ÄÌôò
      sourceBlocks.forEach(sourceBlock => {
        changes.push({
          action: 'update',
          blockId: sourceBlock.id,
          oldType: sourceBlock.type,
          newType: targetBlock.type
        });
      });
      
      return { data: { levelUnified: true }, changes };
    } else {
      // ÎÇ¥Ïö© Î≥ëÌï© (Í∏∞Î≥∏)
      return this.concatenateContent(sourceBlocks, targetBlock, options);
    }
  }
  
  /**
   * ÌÖçÏä§Ìä∏ ÎÇ¥Ïö© Ïó∞Í≤∞
   */
  async concatenateContent(sourceBlocks, targetBlock, options) {
    const separator = options.separator || ' ';
    const changes = [];
    
    // Î™®Îì† ÎÇ¥Ïö© Ï∂îÏ∂ú
    const contents = [
      this.extractTextContent(targetBlock),
      ...sourceBlocks.map(block => this.extractTextContent(block))
    ].filter(content => content.trim());
    
    const mergedContent = contents.join(separator);
    
    // ÌÉÄÍ≤ü Î∏îÎ°ù ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldContent: targetBlock.content,
      newContent: mergedContent,
      contentData: {
        type: 'doc',
        content: [{
          type: 'paragraph',
          content: [{
            type: 'text',
            text: mergedContent
          }]
        }]
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        mergedContent,
        originalLength: targetBlock.content?.length || 0,
        newLength: mergedContent.length,
        blocksMerged: sourceBlocks.length
      },
      changes
    };
  }
  
  /**
   * ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú ÌõÑ Î≥ëÌï©
   */
  async extractAndMergeText(sourceBlocks, targetBlock, options) {
    // Î™®Îì† Î∏îÎ°ùÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
    const extractedTexts = sourceBlocks.map(block => this.extractTextContent(block));
    
    // ÏûÑÏãú ÌÖçÏä§Ìä∏ Î∏îÎ°ù ÏÉùÏÑ±
    const textBlocks = extractedTexts.map((text, index) => ({
      id: `temp_${index}`,
      type: 'text',
      content: text
    }));
    
    // ÌÖçÏä§Ìä∏ Î≥ëÌï© Ïã§Ìñâ
    return this.concatenateContent(textBlocks, targetBlock, options);
  }
  
  /**
   * Ïª¨Îüº Í∑∏Î£π ÏÉùÏÑ±
   */
  async createColumnGroup(sourceBlocks, targetBlock, options) {
    const allBlocks = [targetBlock, ...sourceBlocks];
    const groupId = `column_group_${Date.now()}`;
    const changes = [];
    
    // Í∞Å Î∏îÎ°ùÏùÑ Ïª¨ÎüºÏúºÎ°ú Î≥ÄÌôò
    allBlocks.forEach((block, index) => {
      changes.push({
        action: 'update',
        blockId: block.id,
        oldMetadata: block.metadata || {},
        newMetadata: {
          ...block.metadata,
          isColumnBlock: true,
          columnIndex: index,
          totalColumns: allBlocks.length,
          groupId: groupId
        }
      });
    });
    
    return {
      data: {
        groupId,
        columnCount: allBlocks.length,
        groupType: 'column'
      },
      changes
    };
  }
  
  /**
   * Î≥ëÌï© Í∑úÏπô Ï∞æÍ∏∞ (ÌÜµÌï© Ïª®ÌÖêÏ∏† Ïù¥Îèô ÏãúÏä§ÌÖú)
   */
  findMergeRule(sourceBlocks, targetBlock) {
    const sourceTypes = sourceBlocks.map(block => block.type);
    const targetType = targetBlock.type;
    
    if (this.config.debugMode) {
      console.log('üîç findMergeRule Ïã§Ìñâ:', { sourceTypes, targetType });
    }
    
    // Í∑úÏπôÎì§ÏùÑ Ïö∞ÏÑ†ÏàúÏúÑÏàúÏúºÎ°ú Ï†ïÎ†¨
    const sortedRules = Object.entries(MERGE_RULES).map(([name, rule]) => ({
      name,
      ...rule,
      priority: rule.priority || 0
    })).sort((a, b) => b.priority - a.priority);
    
    // ÌäπÏàò Ï°∞Í±¥ ÌôïÏù∏ (minSourceCount Îì±)
    for (const rule of sortedRules) {
      // ÏµúÏÜå ÏÜåÏä§ Î∏îÎ°ù Ïàò ÌôïÏù∏
      if (rule.minSourceCount && sourceBlocks.length < rule.minSourceCount) {
        continue;
      }
      
      // ÏÜåÏä§ ÌÉÄÏûÖ Ìò∏ÌôòÏÑ± ÌôïÏù∏
      const sourceCompatible = this.checkSourceCompatibility(sourceTypes, rule.sourceTypes);
      if (!sourceCompatible) {
        continue;
      }
      
      // ÌÉÄÍ≤ü ÌÉÄÏûÖ Ìò∏ÌôòÏÑ± ÌôïÏù∏  
      const targetCompatible = this.checkTargetCompatibility(targetType, rule.targetTypes);
      if (!targetCompatible) {
        continue;
      }
      
      // ÌäπÏàò Ï°∞Í±¥Îì§ ÌôïÏù∏
      const specialConditions = this.checkSpecialConditions(rule, sourceBlocks, targetBlock);
      if (!specialConditions) {
        continue;  
      }
      
      if (this.config.debugMode) {
        console.log(`‚úÖ ${rule.name}: Î≥ëÌï© Í∑úÏπô Ï∞æÏùå!`);
      }
      return rule;
    }
    
    if (this.config.debugMode) {
      console.log('‚ùå Ìò∏Ìôò Í∞ÄÎä•Ìïú Î≥ëÌï© Í∑úÏπôÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå');
    }
    return null;
  }
  
  /**
   * ÏÜåÏä§ ÌÉÄÏûÖ Ìò∏ÌôòÏÑ± ÌôïÏù∏
   */
  checkSourceCompatibility(sourceTypes, ruleSourceTypes) {
    // Î™®Îì† ÌÉÄÏûÖ ÌóàÏö© (ANY_TO_ANY Í∑úÏπôÏö©)
    if (ruleSourceTypes.length === ALL_BLOCK_TYPES.length) {
      return true;
    }
    
    // Î™®Îì† ÏÜåÏä§ ÌÉÄÏûÖÏù¥ Í∑úÏπôÏóê Ìè¨Ìï®ÎêòÎäîÏßÄ ÌôïÏù∏
    return sourceTypes.every(type => ruleSourceTypes.includes(type));
  }
  
  /**
   * ÌÉÄÍ≤ü ÌÉÄÏûÖ Ìò∏ÌôòÏÑ± ÌôïÏù∏
   */
  checkTargetCompatibility(targetType, ruleTargetTypes) {
    // Î™®Îì† ÌÉÄÏûÖ ÌóàÏö© (ANY_TO_ANY Í∑úÏπôÏö©)
    if (ruleTargetTypes.length === ALL_BLOCK_TYPES.length) {
      return true;
    }
    
    return ruleTargetTypes.includes(targetType);
  }
  
  /**
   * ÌäπÏàò Ï°∞Í±¥ ÌôïÏù∏
   */
  checkSpecialConditions(rule, sourceBlocks, targetBlock) {
    // Ïª¨Îüº Í∑∏Î£π ÏÉùÏÑ±Ïùò Í≤ΩÏö∞ ÏÜåÏä§ÏôÄ ÌÉÄÍ≤üÏù¥ Í∞ôÏùÄ ÌÉÄÏûÖÏù¥Î©¥ Ï†úÏô∏
    if (rule.name === 'MULTI_TO_COLUMN_GROUP') {
      const allSameType = sourceBlocks.every(block => block.type === targetBlock.type) &&
                         sourceBlocks.length === 1;
      if (allSameType) {
        return false;
      }
    }
    
    // ANY_TO_ANY Í∑úÏπôÏùÄ Îã§Î•∏ Îçî Íµ¨Ï≤¥Ï†ÅÏù∏ Í∑úÏπôÏù¥ ÏóÜÏùÑ ÎïåÎßå ÏÇ¨Ïö©ÌïòÏßÄÎßå,
    // Íµ¨Ï≤¥Ï†ÅÏù∏ Í∞ôÏùÄ ÌÉÄÏûÖ Í∑úÏπôÏù¥ ÏóÜÎäî Í≤ΩÏö∞ÏóêÎäî ÌóàÏö©
    if (rule.name === 'ANY_TO_ANY') {
      // Í∞ôÏùÄ ÌÉÄÏûÖÎÅºÎ¶¨Îäî Íµ¨Ï≤¥Ï†Å Í∑úÏπôÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      if (sourceBlocks.length === 1 && sourceBlocks[0].type === targetBlock.type) {
        const sourceType = sourceBlocks[0].type;
        const targetType = targetBlock.type;
        
        // Íµ¨Ï≤¥Ï†ÅÏù∏ Í∞ôÏùÄ ÌÉÄÏûÖ Í∑úÏπôÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        const hasSpecificRule = Object.values(MERGE_RULES).some(otherRule => 
          otherRule.name !== 'ANY_TO_ANY' &&
          otherRule.sourceTypes.includes(sourceType) && 
          otherRule.targetTypes.includes(targetType)
        );
        
        // Íµ¨Ï≤¥Ï†ÅÏù∏ Í∑úÏπôÏù¥ ÏûàÏúºÎ©¥ ANY_TO_ANYÎäî ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå
        if (hasSpecificRule) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  /**
   * Î≥ëÌï© Í∞ÄÎä•ÏÑ± Í≤ÄÏ¶ù
   */
  validateMerge(sourceBlocks, targetBlock) {
    if (!targetBlock) {
      return { isValid: false, error: 'Target block is required for merge operation' };
    }
    
    if (sourceBlocks.length > this.config.maxMergeItems) {
      return { 
        isValid: false, 
        error: `Too many blocks to merge (max: ${this.config.maxMergeItems})` 
      };
    }
    
    const rule = this.findMergeRule(sourceBlocks, targetBlock);
    if (!rule) {
      return { 
        isValid: false, 
        error: 'No compatible merge rule found',
        sourceTypes: sourceBlocks.map(b => b.type),
        targetType: targetBlock.type
      };
    }
    
    return { isValid: true, rule: rule.description };
  }
  
  // ===== Ïú†Ìã∏Î¶¨Ìã∞ Î©îÏÑúÎìúÎì§ =====
  
  /**
   * Î∏îÎ°ùÏóêÏÑú ÌÖçÏä§Ìä∏ ÎÇ¥Ïö© Ï∂îÏ∂ú
   */
  extractTextContent(block) {
    if (typeof block.content === 'string') {
      return block.content;
    }
    
    if (typeof block.content === 'object' && block.content?.content) {
      // ProseMirror JSON ÌòïÌÉú
      return this.extractFromProseMirrorJSON(block.content);
    }
    
    return '';
  }
  
  /**
   * ProseMirror JSONÏóêÏÑú ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú
   */
  extractFromProseMirrorJSON(jsonContent) {
    if (!jsonContent.content) return '';
    
    let text = '';
    const traverse = (nodes) => {
      nodes.forEach(node => {
        if (node.type === 'text') {
          text += node.text || '';
        } else if (node.content) {
          traverse(node.content);
        }
      });
    };
    
    traverse(jsonContent.content);
    return text;
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖú ÌååÏã±
   */
  parseListItems(content) {
    if (typeof content !== 'string') return [];
    
    const lines = content.split('\n').filter(line => line.trim());
    return lines.map((line, index) => ({
      index: index + 1,
      content: line.replace(/^[\d\-\*\+‚Ä¢]\s*/, '').trim()
    }));
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖú ÏÉùÏÑ±
   */
  createListItem(listType, content, index) {
    const markers = {
      bulletList: '‚Ä¢',
      numberedList: `${index}.`,
      checkList: '‚òê'
    };
    
    return {
      index,
      content,
      marker: markers[listType] || '‚Ä¢'
    };
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÎÇ¥Ïö© Ìè¨Îß∑ÌåÖ
   */
  formatListContent(listType, items) {
    return items.map(item => `${item.marker} ${item.content}`).join('\n');
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÏïÑÏù¥ÌÖú ÎÇ¥Ïö© Î≥ÄÌôò
   */
  convertListItemContent(content, fromType, toType) {
    // Í∏∞Ï°¥ ÎßàÏª§ Ï†úÍ±∞ ÌõÑ ÏÉà ÎßàÏª§ Ï†ÅÏö©
    const cleanContent = content.replace(/^[\d\-\*\+‚Ä¢‚òê‚òë]\s*/, '');
    return cleanContent;
  }
  
  // ===== ÏÉàÎ°úÏö¥ ÌÜµÌï© Ïª®ÌÖêÏ∏† Ïù¥Îèô Ï†ÑÎûµÎì§ =====
  
  /**
   * Î∏îÎ°ùÏùÑ ÌÜ†Í∏ÄÎ°ú ÎûòÌïë
   */
  async wrapInToggle(sourceBlocks, targetBlock, options) {
    const changes = [];
    const toggleTitle = options.title || this.extractTextContent(sourceBlocks[0]) || 'Toggle';
    
    // ÌÜ†Í∏Ä ÎÇ¥Ïö© Íµ¨ÏÑ±
    const toggleContent = sourceBlocks.map(block => ({
      type: block.type,
      content: block.content,
      metadata: block.metadata
    }));
    
    // ÌÉÄÍ≤ü Î∏îÎ°ùÏùÑ ÌÜ†Í∏ÄÎ°ú Î≥ÄÌôò
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldType: targetBlock.type,
      newType: 'toggle',
      oldContent: targetBlock.content,
      newContent: toggleTitle,
      contentData: this.createContentData('toggle', toggleTitle),
      metadata: {
        ...targetBlock.metadata,
        isExpanded: true,
        toggleContent: toggleContent
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        toggleTitle,
        itemsWrapped: sourceBlocks.length,
        newType: 'toggle'
      },
      changes
    };
  }
  
  /**
   * Î∏îÎ°ùÏùÑ ÏΩîÎìúÎ°ú ÎûòÌïë
   */
  async wrapInCode(sourceBlocks, targetBlock, options) {
    const changes = [];
    const language = options.language || 'javascript';
    
    // Î™®Îì† ÏÜåÏä§ Î∏îÎ°ùÏùò ÎÇ¥Ïö©ÏùÑ Ï∂îÏ∂úÌïòÏó¨ ÏΩîÎìúÎ°ú Í≤∞Ìï©
    const codeContent = sourceBlocks
      .map(block => this.extractTextContent(block))
      .join('\n');
    
    // ÌÉÄÍ≤ü Î∏îÎ°ùÏùÑ ÏΩîÎìú Î∏îÎ°ùÏúºÎ°ú Î≥ÄÌôò
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldType: targetBlock.type,
      newType: 'code',
      oldContent: targetBlock.content,
      newContent: codeContent,
      contentData: this.createContentData('code', codeContent),
      metadata: {
        ...targetBlock.metadata,
        language: language,
        showLineNumbers: options.showLineNumbers !== false
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        language,
        linesCount: codeContent.split('\n').length,
        itemsWrapped: sourceBlocks.length
      },
      changes
    };
  }
  
  /**
   * Î∏îÎ°ùÏùÑ Ïù∏Ïö©Íµ¨Î°ú ÎûòÌïë
   */
  async wrapInQuote(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Î™®Îì† ÏÜåÏä§ Î∏îÎ°ùÏùò ÎÇ¥Ïö©ÏùÑ Ï∂îÏ∂úÌïòÏó¨ Ïù∏Ïö©Íµ¨Î°ú Í≤∞Ìï©
    const quoteContent = sourceBlocks
      .map(block => this.extractTextContent(block))
      .join('\n\n');
    
    // ÌÉÄÍ≤ü Î∏îÎ°ùÏùÑ Ïù∏Ïö©Íµ¨Î°ú Î≥ÄÌôò
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldType: targetBlock.type,
      newType: 'quote',
      oldContent: targetBlock.content,
      newContent: quoteContent,
      contentData: this.createContentData('quote', quoteContent),
      metadata: {
        ...targetBlock.metadata,
        author: options.author || null,
        source: options.source || null
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        quoteLength: quoteContent.length,
        itemsWrapped: sourceBlocks.length
      },
      changes
    };
  }
  
  /**
   * Î¶¨Ïä§Ìä∏Î•º ÌÜ†Í∏ÄÎ°ú Î≥ÄÌôò
   */
  async listToToggle(sourceBlocks, targetBlock, options) {
    const changes = [];
    const sourceBlock = sourceBlocks[0];
    const items = this.parseListItems(sourceBlock);
    
    // Ï≤´ Î≤àÏß∏ ÏïÑÏù¥ÌÖúÏùÑ ÌÜ†Í∏Ä Ï†úÎ™©ÏúºÎ°ú, ÎÇòÎ®∏ÏßÄÎ•º ÎÇ¥Ïö©ÏúºÎ°ú
    const toggleTitle = items[0]?.content || 'Toggle';
    const toggleItems = items.slice(1).map(item => ({
      type: 'text',
      content: item.content
    }));
    
    // ÌÉÄÍ≤ü Î∏îÎ°ùÏùÑ ÌÜ†Í∏ÄÎ°ú Î≥ÄÌôò
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldType: targetBlock.type,
      newType: 'toggle',
      oldContent: targetBlock.content,
      newContent: toggleTitle,
      contentData: this.createContentData('toggle', toggleTitle),
      metadata: {
        ...targetBlock.metadata,
        isExpanded: false,
        toggleContent: toggleItems
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ù ÏÇ≠Ï†ú
    changes.push({
      action: 'delete',
      blockId: sourceBlock.id
    });
    
    return {
      data: {
        toggleTitle,
        itemsConverted: items.length,
        originalListType: sourceBlock.type
      },
      changes
    };
  }
  
  /**
   * Î¶¨Ïä§Ìä∏ ÎÇ¥Ïö©ÏùÑ ÌÖçÏä§Ìä∏Î°ú Ï∂îÏ∂ú
   */
  async extractListContent(sourceBlocks, targetBlock, options) {
    return this.concatenateContent(sourceBlocks, targetBlock, {
      ...options,
      separator: options.separator || '\n'
    });
  }
  
  /**
   * Ìó§Îî©ÏùÑ ÌÜ†Í∏ÄÎ°ú Î≥ÄÌôò
   */
  async headingToToggle(sourceBlocks, targetBlock, options) {
    const changes = [];
    const headingContent = this.extractTextContent(sourceBlocks[0]);
    
    // ÌÉÄÍ≤ü Î∏îÎ°ùÏùÑ ÌÜ†Í∏ÄÎ°ú Î≥ÄÌôò
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldType: targetBlock.type,
      newType: 'toggle',
      oldContent: targetBlock.content,
      newContent: headingContent,
      contentData: this.createContentData('toggle', headingContent),
      metadata: {
        ...targetBlock.metadata,
        isExpanded: false,
        toggleContent: [],
        originalHeadingLevel: sourceBlocks[0].type
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ù ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        toggleTitle: headingContent,
        originalType: sourceBlocks[0].type
      },
      changes
    };
  }
  
  /**
   * ÌÜ†Í∏Ä ÎÇ¥Ïö© Î≥ëÌï©
   */
  async mergeToggleContent(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Í∏∞Ï°¥ ÌÜ†Í∏Ä ÎÇ¥Ïö© Í∞ÄÏ†∏Ïò§Í∏∞
    const existingContent = targetBlock.metadata?.toggleContent || [];
    
    // ÏÜåÏä§ ÌÜ†Í∏ÄÎì§Ïùò ÎÇ¥Ïö© Ï∂îÏ∂ú
    const newContent = [];
    sourceBlocks.forEach(sourceBlock => {
      if (sourceBlock.metadata?.toggleContent) {
        newContent.push(...sourceBlock.metadata.toggleContent);
      } else {
        // ÏùºÎ∞ò Î∏îÎ°ùÏù¥Î©¥ Í∑∏ÎåÄÎ°ú Ï∂îÍ∞Ä
        newContent.push({
          type: sourceBlock.type,
          content: sourceBlock.content,
          metadata: sourceBlock.metadata
        });
      }
    });
    
    // ÌÉÄÍ≤ü ÌÜ†Í∏Ä ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldMetadata: targetBlock.metadata,
      newMetadata: {
        ...targetBlock.metadata,
        toggleContent: [...existingContent, ...newContent]
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        itemsAdded: newContent.length,
        totalItems: existingContent.length + newContent.length
      },
      changes
    };
  }
  
  /**
   * ÏΩîÎìú ÎÇ¥Ïö© Î≥ëÌï©
   */
  async mergeCodeContent(sourceBlocks, targetBlock, options) {
    const separator = options.separator || '\n\n';
    const targetContent = this.extractTextContent(targetBlock);
    const sourceContents = sourceBlocks.map(block => this.extractTextContent(block));
    
    const mergedCode = [targetContent, ...sourceContents]
      .filter(content => content.trim())
      .join(separator);
    
    const changes = [{
      action: 'update',
      blockId: targetBlock.id,
      oldContent: targetBlock.content,
      newContent: mergedCode,
      contentData: this.createContentData('code', mergedCode)
    }];
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        mergedLength: mergedCode.length,
        linesCount: mergedCode.split('\n').length
      },
      changes
    };
  }
  
  /**
   * Ïù¥ÎØ∏ÏßÄÎ•º Í∞§Îü¨Î¶¨Ïóê Ï∂îÍ∞Ä
   */
  async addToGallery(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Í∏∞Ï°¥ Í∞§Îü¨Î¶¨ Ïù¥ÎØ∏ÏßÄÎì§
    const existingImages = targetBlock.metadata?.images || [];
    
    // ÏÜåÏä§ Ïù¥ÎØ∏ÏßÄÎì§ Ï∂îÍ∞Ä
    const newImages = sourceBlocks.map(block => ({
      id: block.id,
      src: block.metadata?.src || block.content,
      alt: block.metadata?.alt || '',
      caption: block.metadata?.caption || ''
    }));
    
    // ÌÉÄÍ≤ü Í∞§Îü¨Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldMetadata: targetBlock.metadata,
      newMetadata: {
        ...targetBlock.metadata,
        images: [...existingImages, ...newImages]
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',  
        blockId: block.id
      });
    });
    
    return {
      data: {
        imagesAdded: newImages.length,
        totalImages: existingImages.length + newImages.length
      },
      changes
    };
  }
  
  /**
   * ÌååÏùº Î™©Î°ù Î≥ëÌï©
   */
  async mergeFileList(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Í∏∞Ï°¥ ÌååÏùº Î™©Î°ù
    const existingFiles = targetBlock.metadata?.files || [];
    
    // ÏÜåÏä§ ÌååÏùºÎì§ Ï∂îÍ∞Ä
    const newFiles = sourceBlocks.map(block => ({
      id: block.id,
      name: block.metadata?.fileName || block.content,
      size: block.metadata?.fileSize || 0,
      type: block.metadata?.fileType || 'unknown',
      url: block.metadata?.fileUrl || ''
    }));
    
    // ÌÉÄÍ≤ü ÌååÏùº Î∏îÎ°ù ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldMetadata: targetBlock.metadata,
      newMetadata: {
        ...targetBlock.metadata,
        files: [...existingFiles, ...newFiles]
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        filesAdded: newFiles.length,
        totalFiles: existingFiles.length + newFiles.length
      },
      changes
    };
  }
  
  /**
   * Î∏îÎ°ùÏùÑ Ïª¨ÎüºÏóê Ï∂îÍ∞Ä
   */
  async addToColumn(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // Í∏∞Ï°¥ Ïª¨Îüº ÎÇ¥Ïö©
    const existingContent = targetBlock.metadata?.columnContent || [];
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ÏùÑ Ïª¨Îüº ÎÇ¥Ïö©ÏúºÎ°ú Ï∂îÍ∞Ä
    const newContent = sourceBlocks.map(block => ({
      type: block.type,
      content: block.content,
      metadata: block.metadata
    }));
    
    // ÌÉÄÍ≤ü Ïª¨Îüº ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldMetadata: targetBlock.metadata,
      newMetadata: {
        ...targetBlock.metadata,
        columnContent: [...existingContent, ...newContent]
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });  
    
    return {
      data: {
        itemsAdded: newContent.length,
        totalItems: existingContent.length + newContent.length
      },
      changes
    };
  }
  
  /**
   * Î≤îÏö© Ïª®ÌÖêÏ∏† Ïù¥Îèô (ÏµúÏ¢Ö fallback)
   */
  async universalContentTransfer(sourceBlocks, targetBlock, options) {
    const changes = [];
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§Ïùò ÎÇ¥Ïö©ÏùÑ Ï∂îÏ∂ú
    const sourceContent = sourceBlocks
      .map(block => this.extractTextContent(block))
      .filter(content => content.trim())
      .join('\n\n');
    
    if (!sourceContent) {
      return {
        success: false,
        error: 'No transferable content found'
      };
    }
    
    // ÌÉÄÍ≤ü Î∏îÎ°ù ÌÉÄÏûÖÏóê ÎßûÍ≤å ÎÇ¥Ïö© Î≥ÄÌôò
    const convertedContent = this.adaptContentToBlockType(sourceContent, targetBlock.type);
    const targetContent = this.extractTextContent(targetBlock);
    const finalContent = targetContent ? `${targetContent}\n\n${convertedContent}` : convertedContent;
    
    // ÌÉÄÍ≤ü Î∏îÎ°ù ÏóÖÎç∞Ïù¥Ìä∏
    changes.push({
      action: 'update',
      blockId: targetBlock.id,
      oldContent: targetBlock.content,
      newContent: finalContent,
      contentData: this.createContentData(targetBlock.type, finalContent),
      metadata: {
        ...targetBlock.metadata,
        transferredFrom: sourceBlocks.map(b => b.type)
      }
    });
    
    // ÏÜåÏä§ Î∏îÎ°ùÎì§ ÏÇ≠Ï†ú
    sourceBlocks.forEach(block => {
      changes.push({
        action: 'delete',
        blockId: block.id
      });
    });
    
    return {
      data: {
        transferredContent: sourceContent,
        targetType: targetBlock.type,
        sourceTypes: sourceBlocks.map(b => b.type)
      },
      changes
    };
  }
  
  /**
   * ÎÇ¥Ïö©ÏùÑ Î∏îÎ°ù ÌÉÄÏûÖÏóê ÎßûÍ≤å Ï†ÅÏùë
   */
  adaptContentToBlockType(content, blockType) {
    switch (blockType) {
      case 'bulletList':
        return content.split('\n').map(line => `‚Ä¢ ${line.trim()}`).join('\n');
      case 'numberedList':  
        return content.split('\n').map((line, index) => `${index + 1}. ${line.trim()}`).join('\n');
      case 'checkList':
        return content.split('\n').map(line => `‚òê ${line.trim()}`).join('\n');
      case 'code':
        return content; // ÏΩîÎìúÎäî Í∑∏ÎåÄÎ°ú
      case 'quote':
        return content.split('\n').map(line => `> ${line}`).join('\n');
      default:
        return content; // Í∏∞Î≥∏Ï†ÅÏúºÎ°úÎäî Í∑∏ÎåÄÎ°ú
    }
  }

  /**
   * ÏΩòÌÖêÏ∏† Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± (ProseMirror ÌòïÏãù)
   */
  createContentData(blockType, content) {
    return {
      type: 'doc',
      content: [{
        type: 'paragraph',
        content: [{
          type: 'text',
          text: content || ''
        }]
      }]
    };
  }
}

export default BlockMerger;