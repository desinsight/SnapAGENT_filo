import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Ïù∏Îç±Ïä§ Ï†ÄÏû•Ïö© (Î©îÎ™®Î¶¨)
let fileIndex = [];
let indexedPaths = []; // Ïù∏Îç±Ïã±Îêú Í≤ΩÎ°úÎì§ Í¥ÄÎ¶¨
let indexMetadata = {}; // Í≤ΩÎ°úÎ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞

// Ïù∏Îç±Ïã± ÏÉÅÌÉú Ï†úÏñ¥
let indexingState = {
  isIndexing: false,
  isPaused: false,
  isCanceled: false,
  currentPath: null,
  processedFiles: 0,
  totalFiles: 0
};

// Ï†àÎåÄ Í≤ΩÎ°úÎ°ú ÏÑ§Ï†ï (backend Ìè¥Îçî Í∏∞Ï§Ä)
const INDEX_FILE_PATH = path.join(__dirname, '..', '..', '..', 'data', 'ultra-fast-search', 'index.json');
const PATHS_FILE_PATH = path.join(__dirname, '..', '..', '..', 'data', 'ultra-fast-search', 'indexed-paths.json');
const METADATA_FILE_PATH = path.join(__dirname, '..', '..', '..', 'data', 'ultra-fast-search', 'metadata.json');

// ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
function ensureDirectoryExists(filePath) {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

/**
 * ÏßÄÏ†ïÌïú Ìè¥Îçî(Î∞è ÌïòÏúÑ Ìè¥Îçî) Ï†ÑÏ≤¥Î•º Ïä§Ï∫îÌïòÏó¨ ÌååÏùº Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ïù∏Îç±Ïã±
 * @param {string} rootDir - ÏãúÏûë Ìè¥Îçî Í≤ΩÎ°ú
 */
async function buildIndex(rootDir) {
  console.log(`üîç Ïù∏Îç±Ïã± ÏãúÏûë: ${rootDir}`);
  console.log(`üìç Í≤ΩÎ°ú Ï°¥Ïû¨ Ïó¨Î∂Ä: ${fs.existsSync(rootDir)}`);
  
  // Ïù∏Îç±Ïã± ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
  indexingState.isIndexing = true;
  indexingState.isPaused = false;
  indexingState.isCanceled = false;
  indexingState.currentPath = rootDir;
  indexingState.processedFiles = 0;
  indexingState.totalFiles = 0;
  
  console.log(`üöÄ Ïù∏Îç±Ïã± ÏÉÅÌÉú ÏÑ§Ï†ï ÏôÑÎ£å:`, indexingState);
  
  try {
    // Í∏∞Ï°¥ Ïù∏Îç±Ïä§Ïóê Ï∂îÍ∞Ä (ÎçÆÏñ¥Ïì∞ÏßÄ ÏïäÏùå)
    const newFiles = [];
    await scanDirAsync(rootDir, newFiles);
    
    // Ï∑®ÏÜåÎêú Í≤ΩÏö∞ÏóêÎèÑ ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú Í≤ÉÎì§ Ï†ÄÏû• ÌõÑ Ï§ëÎã®
    if (indexingState.isCanceled) {
      console.log(`‚ùå Ïù∏Îç±Ïã± Ï∑®ÏÜåÎê®: ${rootDir}, ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú ${newFiles.length}Í∞ú ÌååÏùº Ï†ÄÏû• Ï§ë...`);
      
      if (newFiles.length > 0) {
        // Í∏∞Ï°¥ ÌååÏùº Ï§ë Í∞ôÏùÄ Í≤ΩÎ°úÏùò ÌååÏùºÎì§ Ï†úÍ±∞
        const beforeCount = fileIndex.length;
        fileIndex = fileIndex.filter(file => !file.path.startsWith(rootDir));
        
        // ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú ÌååÏùºÎì§ Ï∂îÍ∞Ä
        fileIndex.push(...newFiles);
        
        // Í≤ΩÎ°ú Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (!indexedPaths.includes(rootDir)) {
          indexedPaths.push(rootDir);
        }
        
        // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Î∂ÄÎ∂Ñ ÏôÑÎ£å)
        updatePathMetadata(rootDir, newFiles.length);
        
        // ÌååÏùºÏóê Ï†ÄÏû•
        saveAllData();
        console.log(`üíæ Ï∑®ÏÜå Ïãú Î∂ÄÎ∂Ñ Ï†ÄÏû• ÏôÑÎ£å: ${newFiles.length}Í∞ú ÌååÏùº`);
      }
      
      return false;
    }
    
    console.log(`üìÅ Ïä§Ï∫î ÏôÑÎ£å: ${newFiles.length}Í∞ú ÌååÏùº Î∞úÍ≤¨`);
    
    // Í∏∞Ï°¥ ÌååÏùº Ï§ë Í∞ôÏùÄ Í≤ΩÎ°úÏùò ÌååÏùºÎì§ Ï†úÍ±∞
    const beforeCount = fileIndex.length;
    fileIndex = fileIndex.filter(file => !file.path.startsWith(rootDir));
    console.log(`üóëÔ∏è Í∏∞Ï°¥ ÌååÏùº Ï†úÍ±∞: ${beforeCount - fileIndex.length}Í∞ú`);
    
    // ÏÉà ÌååÏùºÎì§ Ï∂îÍ∞Ä
    fileIndex.push(...newFiles);
    console.log(`‚úÖ ÏÉà ÌååÏùº Ï∂îÍ∞Ä: ${newFiles.length}Í∞ú, Ï†ÑÏ≤¥: ${fileIndex.length}Í∞ú`);
    
    // Í≤ΩÎ°ú Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
    if (!indexedPaths.includes(rootDir)) {
      indexedPaths.push(rootDir);
      console.log(`üìå ÏÉà Í≤ΩÎ°ú Ï∂îÍ∞Ä: ${rootDir}`);
    }
    
    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    updatePathMetadata(rootDir, newFiles.length);
    console.log(`üìä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å`);
    
    // ÌååÏùºÏóê Ï†ÄÏû•
    saveAllData();
    console.log(`üíæ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å`);
    
    return true;
  } catch (error) {
    console.error(`‚ùå Ïù∏Îç±Ïã± Ï§ë Ïò§Î•ò Î∞úÏÉù:`, error);
    throw error;
  } finally {
    // Ïù∏Îç±Ïã± ÏôÑÎ£å ÏÉÅÌÉúÎ°ú Î≥ÄÍ≤Ω
    indexingState.isIndexing = false;
    indexingState.currentPath = null;
    console.log(`üèÅ Ïù∏Îç±Ïã± ÏôÑÎ£å, ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî:`, indexingState);
  }
}

async function scanDirAsync(dir, fileList = []) {
  // Ï∑®ÏÜå ÎòêÎäî ÏùºÏãúÏ†ïÏßÄ Ï≤¥ÌÅ¨
  while (indexingState.isPaused && !indexingState.isCanceled) {
    await new Promise(resolve => setTimeout(resolve, 100)); // 100ms ÎåÄÍ∏∞
  }
  
  if (indexingState.isCanceled) {
    return; // Ï∑®ÏÜåÎê®
  }
  
  let entries;
  try {
    entries = fs.readdirSync(dir, { withFileTypes: true });
    console.log(`üìÇ ÎîîÎ†âÌÜ†Î¶¨ Ïä§Ï∫î: ${dir} (${entries.length}Í∞ú Ìï≠Î™©)`);
  } catch (e) {
    console.warn(`‚ö†Ô∏è ÎîîÎ†âÌÜ†Î¶¨ Ï†ëÍ∑º Ïã§Ìå®: ${dir} - ${e.message}`);
    return;
  }
  
  let fileCount = 0;
  let dirCount = 0;
  let batchFiles = []; // Î∞∞Ïπò Ï≤òÎ¶¨Ïö© ÏûÑÏãú Î∞∞Ïó¥
  
  for (const entry of entries) {
    // Îß§ ÌååÏùºÎßàÎã§ Ï∑®ÏÜå/ÏùºÏãúÏ†ïÏßÄ Ï≤¥ÌÅ¨
    if (indexingState.isCanceled) {
      return;
    }
    
    while (indexingState.isPaused && !indexingState.isCanceled) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      dirCount++;
      await scanDirAsync(fullPath, fileList);
    } else if (entry.isFile()) {
      let stat;
      try {
        stat = fs.statSync(fullPath);
        batchFiles.push(makeFileMeta(fullPath, entry.name, stat));
        fileCount++;
        indexingState.processedFiles++;
        
        // ÌòÑÏû¨ Í≤ΩÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
        indexingState.currentPath = fullPath;
        
        // 100Í∞ú ÌååÏùºÎßàÎã§ Î∞∞Ïπò Ï≤òÎ¶¨ÌïòÏó¨ ÏÑ±Îä• ÏµúÏ†ÅÌôî
        if (batchFiles.length >= 100) {
          fileList.push(...batchFiles);
          batchFiles = [];
          
          // 1000Í∞ú ÌååÏùºÎßàÎã§ Ï§ëÍ∞Ñ Ï†ÄÏû• (Îç∞Ïù¥ÌÑ∞ Î≥¥Ìò∏)
          if (indexingState.processedFiles % 1000 === 0) {
            try {
              // ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú ÌååÏùºÎì§ÏùÑ Î©îÏù∏ Ïù∏Îç±Ïä§Ïóê ÏûÑÏãú Ï∂îÍ∞ÄÌïòÏó¨ Ï†ÄÏû•
              const currentFiles = [...fileList]; // ÌòÑÏû¨ÍπåÏßÄ Ï≤òÎ¶¨Îêú ÌååÏùºÎì§
              
              // Í∏∞Ï°¥ Í∞ôÏùÄ Í≤ΩÎ°ú ÌååÏùºÎì§ Ï†úÍ±∞ÌïòÍ≥† ÏÉàÎ°úÏö¥ ÌååÏùºÎì§ Ï∂îÍ∞Ä
              const filteredIndex = fileIndex.filter(file => !file.path.startsWith(rootDir));
              const tempIndex = [...filteredIndex, ...currentFiles];
              
              // ÏûÑÏãúÎ°ú Ïù∏Îç±Ïä§ ÍµêÏ≤¥ÌïòÏó¨ Ï†ÄÏû•
              const originalIndex = fileIndex;
              fileIndex = tempIndex;
              
              saveAllData();
              console.log(`üíæ Ï§ëÍ∞Ñ Ï†ÄÏû• ÏôÑÎ£å: ${indexingState.processedFiles}Í∞ú ÌååÏùº Ï≤òÎ¶¨Îê®`);
              
              // ÏõêÎûò Ïù∏Îç±Ïä§Î°ú Î≥µÏõê (Ïù∏Îç±Ïã± ÏôÑÎ£å ÌõÑ ÏµúÏ¢Ö Ï†ÄÏû•)
              fileIndex = originalIndex;
              
            } catch (error) {
              console.warn(`‚ö†Ô∏è Ï§ëÍ∞Ñ Ï†ÄÏû• Ïã§Ìå®:`, error);
            }
          }
          
          // Ïù¥Î≤§Ìä∏ Î£®ÌîÑÏóê ÏñëÎ≥¥ÌïòÏó¨ Îã§Î•∏ ÏûëÏóÖ Ï≤òÎ¶¨ ÌóàÏö©
          await new Promise(resolve => setImmediate(resolve));
        }
        
        // 1000Í∞ú ÌååÏùºÎßàÎã§ Î°úÍ∑∏ (Î°úÍπÖ ÎπàÎèÑ Ï§ÑÏûÑ)
        if (indexingState.processedFiles % 1000 === 0) {
          console.log(`üìà ÏßÑÌñâ ÏÉÅÌô©: ${indexingState.processedFiles}Í∞ú ÌååÏùº Ï≤òÎ¶¨Îê®`);
        }
      } catch (e) {
        console.warn(`‚ö†Ô∏è ÌååÏùº Ï†ëÍ∑º Ïã§Ìå®: ${fullPath} - ${e.message}`);
        continue;
      }
    }
  }
  
  // ÎÇ®ÏùÄ ÌååÏùºÎì§ Ï≤òÎ¶¨
  if (batchFiles.length > 0) {
    fileList.push(...batchFiles);
  }
  
  if (fileCount > 0 || dirCount > 0) {
    console.log(`üìÅ ${dir}: ${fileCount}Í∞ú ÌååÏùº, ${dirCount}Í∞ú ÌïòÏúÑ ÎîîÎ†âÌÜ†Î¶¨`);
  }
}

function makeFileMeta(fullPath, name, stat) {
  return {
    name,
    ext: path.extname(name).slice(1),
    path: fullPath,
    size: stat.size,
    mtime: stat.mtime
  };
}

/**
 * Í≤ΩÎ°úÎ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
 */
function updatePathMetadata(rootDir, fileCount) {
  const totalSize = fileIndex
    .filter(file => file.path.startsWith(rootDir))
    .reduce((sum, file) => sum + file.size, 0);
    
  indexMetadata[rootDir] = {
    path: rootDir,
    fileCount,
    totalSize,
    lastUpdated: new Date().toISOString(),
    status: 'active'
  };
}

/**
 * Ïù∏Îç±Ïä§ Î∞òÌôò
 */
function getIndex() {
  return fileIndex;
}

/**
 * Ïù∏Îç±Ïã±Îêú Í≤ΩÎ°úÎì§ Î∞òÌôò
 */
function getIndexedPaths() {
  return indexedPaths;
}

/**
 * Í≤ΩÎ°úÎ≥Ñ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∞òÌôò
 */
function getPathMetadata() {
  return indexMetadata;
}

/**
 * ÌååÏùº Ï∂îÍ∞Ä(WatchÏö©)
 */
function addFileToIndex(filePath, stat) {
  const name = path.basename(filePath);
  // Ïù¥ÎØ∏ ÏûàÏúºÎ©¥ Î¨¥Ïãú
  if (fileIndex.find(f => f.path === filePath)) return;
  
  const fileMeta = makeFileMeta(filePath, name, stat);
  fileIndex.push(fileMeta);
  
  // Ìï¥Îãπ Í≤ΩÎ°úÏùò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
  const rootDir = findRootDirectory(filePath);
  if (rootDir && indexMetadata[rootDir]) {
    indexMetadata[rootDir].fileCount++;
    indexMetadata[rootDir].totalSize += fileMeta.size;
    indexMetadata[rootDir].lastUpdated = new Date().toISOString();
  }
}

/**
 * ÌååÏùº ÏÇ≠Ï†ú(WatchÏö©)
 */
function removeFileFromIndex(filePath) {
  const file = fileIndex.find(f => f.path === filePath);
  if (file) {
    fileIndex = fileIndex.filter(f => f.path !== filePath);
    
    // Ìï¥Îãπ Í≤ΩÎ°úÏùò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    const rootDir = findRootDirectory(filePath);
    if (rootDir && indexMetadata[rootDir]) {
      indexMetadata[rootDir].fileCount--;
      indexMetadata[rootDir].totalSize -= file.size;
      indexMetadata[rootDir].lastUpdated = new Date().toISOString();
    }
  }
}

/**
 * ÌååÏùº Í∞±Ïã†(WatchÏö©)
 */
function updateFileInIndex(filePath, stat) {
  const idx = fileIndex.findIndex(f => f.path === filePath);
  if (idx !== -1) {
    const oldFile = fileIndex[idx];
    const newFile = makeFileMeta(filePath, path.basename(filePath), stat);
    
    // ÌÅ¨Í∏∞ Ï∞®Ïù¥ Í≥ÑÏÇ∞
    const sizeDiff = newFile.size - oldFile.size;
    
    fileIndex[idx] = newFile;
    
    // Ìï¥Îãπ Í≤ΩÎ°úÏùò Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
    const rootDir = findRootDirectory(filePath);
    if (rootDir && indexMetadata[rootDir]) {
      indexMetadata[rootDir].totalSize += sizeDiff;
      indexMetadata[rootDir].lastUpdated = new Date().toISOString();
    }
  }
}

/**
 * ÌååÏùº Í≤ΩÎ°úÏóêÏÑú Î£®Ìä∏ ÎîîÎ†âÌÜ†Î¶¨ Ï∞æÍ∏∞
 */
function findRootDirectory(filePath) {
  return indexedPaths.find(rootDir => filePath.startsWith(rootDir));
}

/**
 * ÌäπÏ†ï Í≤ΩÎ°úÏùò Ïù∏Îç±Ïä§ ÏÇ≠Ï†ú
 * @param {Array} paths - ÏÇ≠Ï†úÌï† Í≤ΩÎ°ú Î∞∞Ïó¥
 */
function removePathsFromIndex(paths) {
  // ÌååÏùº Ïù∏Îç±Ïä§ÏóêÏÑú Ï†úÍ±∞
  fileIndex = fileIndex.filter(file => {
    return !paths.some(pathToRemove => file.path.startsWith(pathToRemove));
  });
  
  // Ïù∏Îç±Ïã±Îêú Í≤ΩÎ°úÏóêÏÑú Ï†úÍ±∞
  indexedPaths = indexedPaths.filter(path => !paths.includes(path));
  
  // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ÏóêÏÑú Ï†úÍ±∞
  paths.forEach(pathToRemove => {
    delete indexMetadata[pathToRemove];
  });
  
  // ÌååÏùºÏóê Ï†ÄÏû•
  saveAllData();
}

/**
 * Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º ÌååÏùºÏóê Ï†ÄÏû•
 */
function saveAllData() {
  ensureDirectoryExists(INDEX_FILE_PATH);

  // Ïù∏Îç±Ïä§ ÌååÏùº Ï†ÄÏû•
  fs.writeFileSync(INDEX_FILE_PATH, JSON.stringify(fileIndex, null, 2), 'utf-8');

  // Í≤ΩÎ°ú Ï†ïÎ≥¥ Ï†ÄÏû• (ÏóÜÏúºÎ©¥ Îπà Î∞∞Ïó¥Î°úÎùºÎèÑ ÏÉùÏÑ±)
  if (!Array.isArray(indexedPaths)) indexedPaths = [];
  fs.writeFileSync(PATHS_FILE_PATH, JSON.stringify(indexedPaths, null, 2), 'utf-8');

  // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï†ÄÏû• (ÏóÜÏúºÎ©¥ Îπà Í∞ùÏ≤¥Î°úÎùºÎèÑ ÏÉùÏÑ±)
  if (typeof indexMetadata !== 'object' || !indexMetadata) indexMetadata = {};
  fs.writeFileSync(METADATA_FILE_PATH, JSON.stringify(indexMetadata, null, 2), 'utf-8');
}

/**
 * Î™®Îì† Îç∞Ïù¥ÌÑ∞Î•º ÌååÏùºÏóêÏÑú Î∂àÎü¨Ïò§Í∏∞
 */
function loadAllData() {
  try {
    // Ïù∏Îç±Ïä§ ÌååÏùº Î∂àÎü¨Ïò§Í∏∞
    if (fs.existsSync(INDEX_FILE_PATH)) {
      const data = fs.readFileSync(INDEX_FILE_PATH, 'utf-8');
      fileIndex = JSON.parse(data);
    }
    
    // Í≤ΩÎ°ú Ï†ïÎ≥¥ Î∂àÎü¨Ïò§Í∏∞
    if (fs.existsSync(PATHS_FILE_PATH)) {
      const data = fs.readFileSync(PATHS_FILE_PATH, 'utf-8');
      indexedPaths = JSON.parse(data);
    }
    
    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞
    if (fs.existsSync(METADATA_FILE_PATH)) {
      const data = fs.readFileSync(METADATA_FILE_PATH, 'utf-8');
      indexMetadata = JSON.parse(data);
    }
    
    return true;
  } catch (error) {
    console.error('Îç∞Ïù¥ÌÑ∞ Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò:', error);
    return false;
  }
}

/**
 * Ïù∏Îç±Ïã± ÏùºÏãúÏ†ïÏßÄ
 */
function pauseIndexing() {
  if (indexingState.isIndexing) {
    indexingState.isPaused = true;
    console.log('‚è∏Ô∏è Ïù∏Îç±Ïã± ÏùºÏãúÏ†ïÏßÄÎê®');
    return true;
  }
  return false;
}

/**
 * Ïù∏Îç±Ïã± Ïû¨Í∞ú
 */
function resumeIndexing() {
  if (indexingState.isIndexing && indexingState.isPaused) {
    indexingState.isPaused = false;
    console.log('‚ñ∂Ô∏è Ïù∏Îç±Ïã± Ïû¨Í∞úÎê®');
    return true;
  }
  return false;
}

/**
 * Ïù∏Îç±Ïã± Ï∑®ÏÜå
 */
function cancelIndexing() {
  if (indexingState.isIndexing) {
    indexingState.isCanceled = true;
    indexingState.isPaused = false;
    console.log('‚ùå Ïù∏Îç±Ïã± Ï∑®ÏÜåÎê®');
    return true;
  }
  return false;
}

/**
 * Ïù∏Îç±Ïã± ÏÉÅÌÉú Ï°∞Ìöå
 */
function getIndexingStatus() {
  const status = {
    ...indexingState,
    progress: indexingState.totalFiles > 0 ? 
      Math.round((indexingState.processedFiles / indexingState.totalFiles) * 100) : 0
  };
  
  console.log(`üîç Ïù∏Îç±Ïã± ÏÉÅÌÉú Ï°∞Ìöå:`, status);
  return status;
}

/**
 * ÏÑúÎ≤Ñ ÏãúÏûë Ïãú ÏûêÎèôÏúºÎ°ú Îç∞Ïù¥ÌÑ∞ Î°úÎìú
 */
loadAllData();

export {
  buildIndex,
  getIndex,
  getIndexedPaths,
  getPathMetadata,
  addFileToIndex,
  removeFileFromIndex,
  updateFileInIndex,
  saveAllData,
  loadAllData,
  removePathsFromIndex,
  pauseIndexing,
  resumeIndexing,
  cancelIndexing,
  getIndexingStatus
};