const mongoose = require('mongoose');

/**
 * 회계 거래(전표) 스키마 - 복식부기 회계의 핵심 데이터 구조
 * 차변과 대변이 항상 균형을 이루는 구조로 설계
 */
const transactionSchema = new mongoose.Schema({
  // 전표 기본 정보
  transactionNumber: {
    type: String,
    required: true,
    unique: true,
    comment: '전표번호 (자동 생성)'
  },
  
  transactionDate: {
    type: Date,
    required: true,
    comment: '거래일자'
  },
  
  postingDate: {
    type: Date,
    required: true,
    comment: '전표일자'
  },
  
  // 전표 유형 및 상태
  transactionType: {
    type: String,
    enum: ['일반전표', '수입전표', '지출전표', '이체전표', '기말정리', '조정분개'],
    default: '일반전표',
    comment: '전표 유형'
  },
  
  status: {
    type: String,
    enum: ['draft', 'posted', 'cancelled', 'reversed'],
    default: 'draft',
    comment: '전표 상태'
  },
  
  // 전표 요약 정보
  description: {
    type: String,
    required: true,
    trim: true,
    comment: '전표 적요'
  },
  
  reference: {
    type: String,
    trim: true,
    comment: '참조번호 (영수증번호, 계약번호 등)'
  },
  
  // 금액 정보
  totalAmount: {
    type: Number,
    required: true,
    min: 0,
    comment: '전표 총 금액'
  },
  
  currency: {
    type: String,
    default: 'KRW',
    comment: '통화'
  },
  
  exchangeRate: {
    type: Number,
    default: 1,
    comment: '환율'
  },
  
  // 세무 관련 정보
  taxInfo: {
    vatAmount: {
      type: Number,
      default: 0,
      comment: '부가세 금액'
    },
    vatRate: {
      type: Number,
      default: 0.1,
      comment: '부가세율'
    },
    isVatIncluded: {
      type: Boolean,
      default: false,
      comment: '부가세 포함 여부'
    },
    taxCategory: {
      type: String,
      enum: ['과세', '면세', '영세', '불공제'],
      comment: '세무 분류'
    }
  },
  
  // 거래처 정보
  counterparty: {
    businessNumber: {
      type: String,
      trim: true,
      comment: '거래처 사업자등록번호'
    },
    name: {
      type: String,
      trim: true,
      comment: '거래처명'
    },
    contact: {
      type: String,
      comment: '거래처 연락처'
    }
  },
  
  // 전표 상세 (차변/대변)
  entries: [{
    accountCode: {
      type: String,
      required: true,
      comment: '계정과목 코드'
    },
    
    accountName: {
      type: String,
      required: true,
      comment: '계정과목명'
    },
    
    debitAmount: {
      type: Number,
      default: 0,
      min: 0,
      comment: '차변 금액'
    },
    
    creditAmount: {
      type: Number,
      default: 0,
      min: 0,
      comment: '대변 금액'
    },
    
    description: {
      type: String,
      trim: true,
      comment: '개별 적요'
    },
    
    // 세무 분류
    taxCategory: {
      type: String,
      enum: ['과세', '면세', '영세', '불공제', '공제'],
      comment: '세무 분류'
    },
    
    vatCategory: {
      type: String,
      enum: ['과세', '면세', '영세', '불공제'],
      comment: '부가세 분류'
    },
    
    // 분석 코드
    analysisCodes: [{
      code: {
        type: String,
        comment: '분석 코드'
      },
      value: {
        type: String,
        comment: '분석 값'
      }
    }],
    
    // 첨부파일
    attachments: [{
      filename: String,
      originalName: String,
      mimeType: String,
      size: Number,
      url: String
    }]
  }],
  
  // 승인 정보
  approval: {
    isApproved: {
      type: Boolean,
      default: false,
      comment: '승인 여부'
    },
    approvedBy: {
      type: String,
      comment: '승인자'
    },
    approvedAt: {
      type: Date,
      comment: '승인일시'
    },
    approvalNote: {
      type: String,
      comment: '승인 메모'
    }
  },
  
  // 자동화 정보
  automation: {
    isAutoGenerated: {
      type: Boolean,
      default: false,
      comment: '자동 생성 여부'
    },
    sourceType: {
      type: String,
      enum: ['bank', 'receipt', 'invoice', 'payroll', 'system'],
      comment: '자동 생성 소스'
    },
    sourceId: {
      type: String,
      comment: '소스 ID'
    },
    templateId: {
      type: String,
      comment: '템플릿 ID'
    }
  },
  
  // 첨부파일
  attachments: [{
    filename: {
      type: String,
      required: true
    },
    originalName: {
      type: String,
      required: true
    },
    mimeType: {
      type: String,
      required: true
    },
    size: {
      type: Number,
      required: true
    },
    url: {
      type: String,
      required: true
    },
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // 메타데이터
  createdBy: {
    type: String,
    required: true,
    comment: '작성자'
  },
  
  lastModifiedBy: {
    type: String,
    comment: '최종 수정자'
  },
  
  // 조직 정보
  organizationId: {
    type: String,
    required: true,
    comment: '조직 ID'
  },
  
  // 회계연도
  fiscalYear: {
    type: Number,
    required: true,
    comment: '회계연도'
  },
  
  // 회계기간
  fiscalPeriod: {
    type: Number,
    required: true,
    comment: '회계기간 (1-12)'
  },
  
  // 태그
  tags: [{
    type: String,
    comment: '태그'
  }],
  
  // 메모
  notes: {
    type: String,
    comment: '메모'
  }
}, {
  timestamps: true,
  collection: 'transactions'
});

// 인덱스 설정
transactionSchema.index({ transactionNumber: 1 });
transactionSchema.index({ transactionDate: 1 });
transactionSchema.index({ postingDate: 1 });
transactionSchema.index({ status: 1 });
transactionSchema.index({ organizationId: 1 });
transactionSchema.index({ fiscalYear: 1, fiscalPeriod: 1 });
transactionSchema.index({ 'entries.accountCode': 1 });
transactionSchema.index({ 'counterparty.businessNumber': 1 });
transactionSchema.index({ createdBy: 1 });
transactionSchema.index({ 'automation.sourceType': 1, 'automation.sourceId': 1 });

// 복합 인덱스
transactionSchema.index({ organizationId: 1, transactionDate: 1 });
transactionSchema.index({ organizationId: 1, status: 1 });
transactionSchema.index({ organizationId: 1, fiscalYear: 1, fiscalPeriod: 1 });

// 가상 필드
transactionSchema.virtual('isBalanced').get(function() {
  const totalDebit = this.entries.reduce((sum, entry) => sum + entry.debitAmount, 0);
  const totalCredit = this.entries.reduce((sum, entry) => sum + entry.creditAmount, 0);
  return Math.abs(totalDebit - totalCredit) < 0.01; // 부동소수점 오차 허용
});

transactionSchema.virtual('entryCount').get(function() {
  return this.entries.length;
});

transactionSchema.virtual('hasVat').get(function() {
  return this.taxInfo.vatAmount > 0;
});

// 인스턴스 메서드
transactionSchema.methods.getTotalDebit = function() {
  return this.entries.reduce((sum, entry) => sum + entry.debitAmount, 0);
};

transactionSchema.methods.getTotalCredit = function() {
  return this.entries.reduce((sum, entry) => sum + entry.creditAmount, 0);
};

transactionSchema.methods.getBalance = function() {
  return this.getTotalDebit() - this.getTotalCredit();
};

transactionSchema.methods.isBalanced = function() {
  return Math.abs(this.getBalance()) < 0.01;
};

transactionSchema.methods.addEntry = function(entry) {
  this.entries.push(entry);
  this.updateTotalAmount();
  return this;
};

transactionSchema.methods.updateTotalAmount = function() {
  this.totalAmount = Math.max(this.getTotalDebit(), this.getTotalCredit());
  return this;
};

transactionSchema.methods.approve = function(approvedBy, note = '') {
  this.approval.isApproved = true;
  this.approval.approvedBy = approvedBy;
  this.approval.approvedAt = new Date();
  this.approval.approvalNote = note;
  this.status = 'posted';
  return this;
};

transactionSchema.methods.cancel = function(cancelledBy, reason = '') {
  this.status = 'cancelled';
  this.notes = reason;
  this.lastModifiedBy = cancelledBy;
  return this;
};

// 정적 메서드
transactionSchema.statics.generateTransactionNumber = function(organizationId, date) {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  
  return `${organizationId}-${year}${month}${day}-${Date.now()}`;
};

transactionSchema.statics.findByDateRange = function(organizationId, startDate, endDate) {
  return this.find({
    organizationId,
    transactionDate: { $gte: startDate, $lte: endDate },
    status: { $ne: 'cancelled' }
  }).sort({ transactionDate: 1, transactionNumber: 1 });
};

transactionSchema.statics.findByAccount = function(organizationId, accountCode, startDate, endDate) {
  return this.find({
    organizationId,
    'entries.accountCode': accountCode,
    transactionDate: { $gte: startDate, $lte: endDate },
    status: { $ne: 'cancelled' }
  }).sort({ transactionDate: 1 });
};

transactionSchema.statics.findByFiscalPeriod = function(organizationId, fiscalYear, fiscalPeriod) {
  return this.find({
    organizationId,
    fiscalYear,
    fiscalPeriod,
    status: { $ne: 'cancelled' }
  }).sort({ transactionDate: 1, transactionNumber: 1 });
};

// 미들웨어
transactionSchema.pre('save', function(next) {
  // 전표번호 자동 생성
  if (!this.transactionNumber) {
    this.transactionNumber = this.constructor.generateTransactionNumber(
      this.organizationId, 
      this.transactionDate
    );
  }
  
  // 회계연도/기간 자동 설정
  if (!this.fiscalYear) {
    this.fiscalYear = this.transactionDate.getFullYear();
  }
  if (!this.fiscalPeriod) {
    this.fiscalPeriod = this.transactionDate.getMonth() + 1;
  }
  
  // 총 금액 업데이트
  this.updateTotalAmount();
  
  // 차변/대변 균형 검증
  if (!this.isBalanced()) {
    return next(new Error('차변과 대변의 합계가 일치하지 않습니다.'));
  }
  
  next();
});

// JSON 변환 시 가상 필드 포함
transactionSchema.set('toJSON', {
  virtuals: true,
  transform: function(doc, ret) {
    delete ret.__v;
    return ret;
  }
});

module.exports = mongoose.model('Transaction', transactionSchema); 